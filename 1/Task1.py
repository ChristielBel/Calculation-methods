import math


# Функция для вычисления erf(x) с помощью ряда Тейлора
def erf_taylor(x, tolerance=1e-15):
    # Константа 2/√π
    constant = 2 / math.sqrt(math.pi)

    # Инициализация переменных
    term = x  # Первый член ряда
    sum_erf = term  # Инициализация суммы с первым членом
    n = 1  # Счётчик для членов ряда

    # Рекурсивное вычисление каждого члена ряда, избегая больших степеней (чтобы избежать переполнение)
    while abs(term) > tolerance:
        term *= -x * x / n  # Рекуррентное отношение для нового члена ряда
        # Вместо того чтобы вычислять каждый член ряда как x^2n+1 с нуля,
        # новый член ряда вычисляется на основе предыдущего.
        # Это уменьшает количество операций с большими числами и предотвращает переполнение.
        sum_erf += term / (2 * n + 1)
        n += 1

    return constant * sum_erf

x_values = [0.5, 1.0, 5.0, 10.0]
for x in x_values:
    erf_approx = erf_taylor(x)
    erf_exact = math.erf(x)
    print(
        f"x = {x}, вычисленная erf(x) = {erf_taylor(x)}, точная erf(x) = {erf_exact}, разница = {abs(erf_approx - erf_exact)}")
